# Реверс односвязного списка

## Описание задачи

Необходимо развернуть односвязный список, то есть изменить порядок его элементов на противоположный.

### Пример
- Входные данные: `1 -> 2 -> 3 -> 4 -> 5`
- Результат: `5 -> 4 -> 3 -> 2 -> 1`

---

## Логика решения

Для выполнения задачи используется метод `reverse`, который работает по следующему алгоритму:
1. Вводятся три указателя:
   - `prev` — отслеживает предыдущий узел. Изначально равен `None`.
   - `current` — текущий узел. Изначально указывает на голову списка (`head`).
   - `next_node` — временный указатель для сохранения ссылки на следующий узел.
2. В цикле:
   - Сохраняется ссылка на следующий узел в `next_node`.
   - Ссылка текущего узла изменяется на предыдущий узел: `current.next = prev`.
   - Указатель `prev` сдвигается на текущий узел.
   - Указатель `current` сдвигается на следующий узел.
3. После завершения цикла последний обработанный узел (`prev`) становится новой головой списка (`head`).

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Алгоритм проходит по каждому узлу списка ровно один раз. Таким образом, временная сложность составляет **O(n)**, где \( n \) — количество узлов в списке.

2. **Затраты по памяти**:
   - Используются три дополнительных указателя (`prev`, `current`, `next_node`), что требует фиксированного объема памяти, не зависящего от размера списка. Следовательно, сложность по памяти составляет **O(1)**.

---

## Итог

Алгоритм реверса односвязного списка:
- Эффективен по времени — \( O(n) \).
- Эффективен по памяти — \( O(1) \).
- Выполняется "на месте", без создания дополнительных структур данных, что делает его оптимальным решением для данной задачи.
