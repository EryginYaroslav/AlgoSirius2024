# TASK 1

## Описание задачи

Необходимо развернуть односвязный список, то есть изменить порядок его элементов на противоположный.

### Пример
- Входные данные: `1 -> 2 -> 3 -> 4 -> 5`
- Результат: `5 -> 4 -> 3 -> 2 -> 1`

---

## Логика решения

Для выполнения задачи используется метод `reverse`, который работает по следующему алгоритму:
1. Вводятся три указателя:
   - `prev` — отслеживает предыдущий узел. Изначально равен `None`.
   - `current` — текущий узел. Изначально указывает на голову списка (`head`).
   - `next_node` — временный указатель для сохранения ссылки на следующий узел.
2. В цикле:
   - Сохраняется ссылка на следующий узел в `next_node`.
   - Ссылка текущего узла изменяется на предыдущий узел: `current.next = prev`.
   - Указатель `prev` сдвигается на текущий узел.
   - Указатель `current` сдвигается на следующий узел.
3. После завершения цикла последний обработанный узел (`prev`) становится новой головой списка (`head`).

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Алгоритм проходит по каждому узлу списка ровно один раз. Таким образом, временная сложность составляет **O(n)**, где \( n \) — количество узлов в списке.

2. **Затраты по памяти**:
   - Используются три дополнительных указателя (`prev`, `current`, `next_node`), что требует фиксированного объема памяти, не зависящего от размера списка. Следовательно, сложность по памяти составляет **O(1)**.

---

## Итог

Алгоритм реверса односвязного списка:
- Эффективен по времени — \( O(n) \).
- Эффективен по памяти — \( O(1) \).
- Выполняется "на месте", без создания дополнительных структур данных, что делает его оптимальным решением для данной задачи.

# TASK 2
## Логика решения

1. **Расчет релевантности**:
   - Для каждого объекта вычисляется начальная релевантность на основе заданной формулы.

2. **Обработка запросов**:
   - Для запроса типа `1 k`:
     - Определяются индексы топ-k объектов по релевантности.
     - Индексы сортируются по убыванию релевантности, а при равных значениях — по возрастанию.
   - Для запроса типа `2 i j v`:
     - Обновляется значение признака `j` для объекта `i`.
     - Пересчитывается релевантность объекта `i`.

3. **Оптимизация**:
   - Используется сортировка только для необходимых объектов при запросах топ-k, что позволяет эффективно обрабатывать запросы.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Вычисление начальной релевантности: **O(n × d)**.
   - Запросы типа `1 k` (топ-k): **O(k × d)** для каждого запроса.
   - Запросы типа `2 i j v` (обновление): **O(1)**.
   - Итоговая сложность: зависит от количества запросов и их типов.

2. **Затраты по памяти**:
   - Хранение весов `a`: **O(n)**.
   - Хранение признаков объектов `features`: **O(n × d)**.
   - Хранение релевантности: **O(d)**.
   - Итоговая сложность по памяти: **O(n × d)**.

---
# TASK 3

## Описание задачи

Необходимо инвертировать бинарное дерево поиска, то есть перестроить его таким образом, чтобы для каждого узла:
- Все узлы справа от материнского узла имели значения **меньше**, чем значение материнского узла.
- Все узлы слева от материнского узла имели значения **больше**, чем значение материнского узла.

---

## Формат задачи

1. **Входные данные**:
   - Бинарное дерево поиска, представленное узлами, где каждый узел содержит:
     - `value` — значение узла.
     - `left` — ссылка на левое поддерево.
     - `right` — ссылка на правое поддерево.

2. **Выходные данные**:
   - Инверсированное бинарное дерево, где порядок узлов инвертирован согласно описанным условиям.

---

## Логика решения

1. **Рекурсивная инверсия**:
   - Для каждого узла дерева вызывается рекурсивная функция `invert_tree`.
   - Внутри функции для текущего узла выполняется обмен ссылок на левое и правое поддеревья:
     ```
     root.left, root.right = invert_tree(root.right), invert_tree(root.left)
     ```
   - Процесс рекурсивно повторяется для всех дочерних узлов.

2. **Обход дерева (inorder)**:
   - Для проверки корректности инверсии используется симметричный (inorder) обход дерева.
   - Этот обход рекурсивно проходит левое поддерево, затем посещает текущий узел и, наконец, правое поддерево, что позволяет вывести узлы дерева в отсортированном порядке.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Каждое поддерево посещается ровно один раз, а перестановка ссылок происходит за \( O(1) \). Таким образом, сложность инверсии составляет **O(n)**, где \( n \) — количество узлов в дереве.

2. **Затраты по памяти**:
   - Инверсия выполняется рекурсивно, что требует памяти для хранения стека вызовов. Глубина стека вызовов равна высоте дерева, которая может быть:
     - В среднем случае для сбалансированного дерева: **O(log(n))**.
     - В худшем случае для несбалансированного дерева: **O(n)**.

---

