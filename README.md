# TASK 1

## Описание задачи

Необходимо развернуть односвязный список, то есть изменить порядок его элементов на противоположный.

### Пример
- Входные данные: `1 -> 2 -> 3 -> 4 -> 5`
- Результат: `5 -> 4 -> 3 -> 2 -> 1`

---

## Логика решения

Для выполнения задачи используется метод `reverse`, который работает по следующему алгоритму:
1. Вводятся три указателя:
   - `prev` — отслеживает предыдущий узел. Изначально равен `None`.
   - `current` — текущий узел. Изначально указывает на голову списка (`head`).
   - `next_node` — временный указатель для сохранения ссылки на следующий узел.
2. В цикле:
   - Сохраняется ссылка на следующий узел в `next_node`.
   - Ссылка текущего узла изменяется на предыдущий узел: `current.next = prev`.
   - Указатель `prev` сдвигается на текущий узел.
   - Указатель `current` сдвигается на следующий узел.
3. После завершения цикла последний обработанный узел (`prev`) становится новой головой списка (`head`).

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Алгоритм проходит по каждому узлу списка ровно один раз. Таким образом, временная сложность составляет **O(n)**, где \( n \) — количество узлов в списке.

2. **Затраты по памяти**:
   - Используются три дополнительных указателя (`prev`, `current`, `next_node`), что требует фиксированного объема памяти, не зависящего от размера списка. Следовательно, сложность по памяти составляет **O(1)**.

---

## Итог

Алгоритм реверса односвязного списка:
- Эффективен по времени — \( O(n) \).
- Эффективен по памяти — \( O(1) \).
- Выполняется "на месте", без создания дополнительных структур данных, что делает его оптимальным решением для данной задачи.

# TASK 2
## Логика решения

1. **Расчет релевантности**:
   - Для каждого объекта вычисляется начальная релевантность на основе заданной формулы.

2. **Обработка запросов**:
   - Для запроса типа `1 k`:
     - Определяются индексы топ-k объектов по релевантности.
     - Индексы сортируются по убыванию релевантности, а при равных значениях — по возрастанию.
   - Для запроса типа `2 i j v`:
     - Обновляется значение признака `j` для объекта `i`.
     - Пересчитывается релевантность объекта `i`.

3. **Оптимизация**:
   - Используется сортировка только для необходимых объектов при запросах топ-k, что позволяет эффективно обрабатывать запросы.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Вычисление начальной релевантности: **O(n × d)**.
   - Запросы типа `1 k` (топ-k): **O(k × d)** для каждого запроса.
   - Запросы типа `2 i j v` (обновление): **O(1)**.
   - Итоговая сложность: зависит от количества запросов и их типов.

2. **Затраты по памяти**:
   - Хранение весов `a`: **O(n)**.
   - Хранение признаков объектов `features`: **O(n × d)**.
   - Хранение релевантности: **O(d)**.
   - Итоговая сложность по памяти: **O(n × d)**.

---
# TASK 3

## Описание задачи

Необходимо инвертировать бинарное дерево поиска, то есть перестроить его таким образом, чтобы для каждого узла:
- Все узлы справа от материнского узла имели значения **меньше**, чем значение материнского узла.
- Все узлы слева от материнского узла имели значения **больше**, чем значение материнского узла.

---

## Формат задачи

1. **Входные данные**:
   - Бинарное дерево поиска, представленное узлами, где каждый узел содержит:
     - `value` — значение узла.
     - `left` — ссылка на левое поддерево.
     - `right` — ссылка на правое поддерево.

2. **Выходные данные**:
   - Инверсированное бинарное дерево, где порядок узлов инвертирован согласно описанным условиям.

---

## Логика решения

1. **Рекурсивная инверсия**:
   - Для каждого узла дерева вызывается рекурсивная функция `invert_tree`.
   - Внутри функции для текущего узла выполняется обмен ссылок на левое и правое поддеревья:
     ```
     root.left, root.right = invert_tree(root.right), invert_tree(root.left)
     ```
   - Процесс рекурсивно повторяется для всех дочерних узлов.

2. **Обход дерева (inorder)**:
   - Для проверки корректности инверсии используется симметричный (inorder) обход дерева.
   - Этот обход рекурсивно проходит левое поддерево, затем посещает текущий узел и, наконец, правое поддерево, что позволяет вывести узлы дерева в отсортированном порядке.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Каждое поддерево посещается ровно один раз, а перестановка ссылок происходит за \( O(1) \). Таким образом, сложность инверсии составляет **O(n)**, где \( n \) — количество узлов в дереве.

2. **Затраты по памяти**:
   - Инверсия выполняется рекурсивно, что требует памяти для хранения стека вызовов. Глубина стека вызовов равна высоте дерева, которая может быть:
     - В среднем случае для сбалансированного дерева: **O(log(n))**.
     - В худшем случае для несбалансированного дерева: **O(n)**.

---

# TASK 4

## Описание задачи

Реализовать красно-черное дерево (КЧД) — сбалансированное бинарное дерево поиска, где каждая вставка нового узла автоматически выполняет балансировку для сохранения свойств дерева.

---

## Основные свойства красно-черного дерева

1. Каждый узел имеет цвет: **красный** или **черный**.
2. Корень дерева всегда **черный**.
3. Все листья (нулевые узлы) являются **черными**.
4. Если узел **красный**, оба его дочерних узла должны быть **черными** (никакие два красных узла не могут быть смежными).
5. На каждом пути от корня до листа количество черных узлов одинаково (черная высота).

Эти свойства обеспечивают сбалансированность дерева, что позволяет выполнять операции поиска, вставки и удаления за логарифмическое время.

---

## Логика решения

### Основные операции

1. **Вставка нового узла**:
   - Новый узел всегда добавляется с цветом **красный**.
   - Если добавление узла нарушает свойства КЧД, выполняется балансировка через метод `fix_insert`.

2. **Балансировка (fix_insert)**:
   - Если родитель нового узла также красный, выполняется одна из следующих операций:
     - **Перекрашивание**: Если дядя узла красный, цвета родителя, дяди и дедушки меняются.
     - **Повороты**:
       - Левый поворот (left_rotate).
       - Правый поворот (right_rotate).

3. **Повороты**:
   - Повороты выполняются для восстановления структуры дерева, когда перекрашивание не может устранить нарушение свойств.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Вставка нового узла: \( O(\log n) \).
   - Балансировка (fix_insert): \( O(\log n) \), так как высота дерева пропорциональна логарифму от числа узлов.
   - Итоговая сложность вставки: \( O(\log n) \).

2. **Затраты по памяти**:
   - Каждый узел хранит значение, цвет, а также ссылки на родителя и дочерние узлы, что требует \( O(n) \) памяти для хранения всех узлов.

---

# TASK 5

## Описание задачи

Реализовать структуру данных для хранения пар "ключ-значение" на основе красно-черного дерева. Дерево должно поддерживать операции:
- Вставка новой пары (или обновление значения по существующему ключу).
- Поиск значения по ключу.
- Симметричный обход дерева для получения отсортированного списка пар.

Красно-черное дерево обеспечивает балансировку для эффективной вставки, удаления и поиска данных.

---

## Основные свойства красно-черного дерева

1. Каждый узел имеет цвет: **красный** или **черный**.
2. Корень дерева всегда **черный**.
3. Все листья (нулевые узлы) являются **черными**.
4. Если узел **красный**, оба его дочерних узла должны быть **черными**.
5. На каждом пути от корня до листа количество черных узлов одинаково (черная высота).

Эти свойства обеспечивают сбалансированность дерева, что позволяет выполнять операции за \( O(\log n) \).

---

## Логика решения

### Основные операции

1. **Вставка новой пары (insert)**:
   - Находим подходящее место для вставки нового узла с ключом и значением.
   - Если ключ уже существует, обновляем значение.
   - Новый узел всегда добавляется с цветом **красный**.
   - После вставки выполняется метод `fix_insert` для восстановления свойств красно-черного дерева:
     - Перекрашивание узлов.
     - Левый или правый поворот, если требуется.

2. **Поиск значения по ключу (search)**:
   - Осуществляется стандартный бинарный поиск по ключу.

3. **Симметричный обход дерева (inorder_traversal)**:
   - Обходит дерево от меньших к большим ключам и возвращает список пар (ключ, значение, цвет узла).

4. **Вывод дерева (print_tree)**:
   - Отображает дерево в текстовом формате, включая ключ, значение и цвет каждого узла.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Вставка нового узла: \( O(\log n) \).
   - Поиск по ключу: \( O(\log n) \).
   - Обход дерева: \( O(n) \).

2. **Затраты по памяти**:
   - Хранение каждого узла с ключом, значением, цветом, а также ссылками на родителя и дочерние узлы: \( O(n) \).

---

# TASK 6
## Описание задачи

Дана информация о времени заезда и отъезда посетителей отеля. Необходимо определить день, в который в отеле одновременно находилось максимальное количество посетителей.

## Логика решения

1. **Разделение событий заезда и отъезда**:
   - Каждое событие "заезд" увеличивает количество посетителей на 1 в день заезда.
   - Каждое событие "отъезд" уменьшает количество посетителей на 1 на следующий день после отъезда.

2. **Агрегация изменений**:
   - Используется словарь для подсчета изменений в количестве посетителей по дням.

3. **Сортировка событий**:
   - Все даты сортируются в хронологическом порядке для подсчета количества посетителей по каждому дню.

4. **Подсчет количества посетителей**:
   - Используется текущая сумма изменений для определения количества посетителей на каждый день.
   - Сохраняется день с максимальным количеством посетителей.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Обработка данных: \( O(n) \), где \( n \) — количество записей о посетителях.
   - Сортировка событий: \( O(m \log m) \), где \( m \) — количество уникальных дат.
   - Итоговая сложность: \( O(n + m \log m) \).

2. **Затраты по памяти**:
   - Хранение словаря событий: \( O(m) \), где \( m \) — количество уникальных дат.

---

# TASK 7

## Описание задачи

Реализовать алгоритм Беллмана-Форда для нахождения кратчайших расстояний от заданной вершины до всех остальных вершин в графе. Алгоритм также позволяет определить наличие отрицательных циклов в графе.

---

## Особенности алгоритма

1. Алгоритм работает на графах с отрицательными весами рёбер.
2. Обеспечивает нахождение кратчайших путей, если граф не содержит отрицательных циклов.
3. Если в графе есть отрицательный цикл, алгоритм обнаруживает его.

---

## Логика решения

### Основные шаги

1. **Инициализация расстояний**:
   - Для всех вершин расстояние от исходной вершины (`source`) устанавливается в бесконечность (\( \infty \)).
   - Расстояние до исходной вершины устанавливается в `0`.

2. **Расслабление рёбер**:
   - Все рёбра графа последовательно проверяются \( |V| - 1 \) раз (где \( |V| \) — количество вершин).
   - Если через текущее ребро можно уменьшить расстояние до конечной вершины, расстояние обновляется.

3. **Проверка на отрицательные циклы**:
   - После завершения расслабления выполняется дополнительный проход по рёбрам.
   - Если можно ещё раз уменьшить расстояние, граф содержит отрицательный цикл.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Расслабление рёбер выполняется \( |V| - 1 \) раз для \( |E| \) рёбер. Итоговая сложность: \( O(V \times E) \).

2. **Затраты по памяти**:
   - Необходим массив для хранения расстояний до каждой вершины. Итоговая сложность: \( O(V) \).

---

# TASK 8

## Описание задачи

Венгерский алгоритм — это эффективный метод решения задач комбинаторной оптимизации, таких как минимизация стоимости сопоставления в задаче о назначениях. Алгоритм работает с матрицей стоимости и находит оптимальное сопоставление строк и столбцов, минимизируя общую стоимость.

---

## Основные этапы венгерского алгоритма

1. **Выравнивание строк**:
   - Вычесть минимальное значение каждой строки из всех элементов строки.

2. **Выравнивание столбцов**:
   - Для каждого столбца, если есть нулевые элементы, выполнить маркировку.

3. **Проверка оптимальности**:
   - Если можно покрыть все нули минимальным количеством линий, найдено оптимальное решение.

4. **Создание новых нулей**:
   - Если оптимальное решение не найдено, определить минимальное непокрытое значение, вычесть его из всех непокрытых элементов и добавить к покрытым.

5. **Повторение шагов**:
   - Повторить процесс до нахождения оптимального сопоставления.

---

## Логика решения

1. **Инициализация**:
   - Матрица стоимости загружается, преобразуется в numpy-массив.
   - Инициализируются вспомогательные структуры данных: массивы для покрытия строк и столбцов, матрица маркировок.

2. **Реализация основных шагов алгоритма**:
   - `step1`: Вычитание минимального значения каждой строки из строки.
   - `step2`: Маркировка нулей.
   - `step3`: Проверка покрытия всех нулей.
   - `step4`: Поиск непокрытых нулей и обновление матрицы.
   - `step5`: Построение пути и обновление матрицы маркировок.
   - `step6`: Создание новых нулей.

3. **Оптимальное сопоставление**:
   - После нахождения всех необходимых покрытий, возвращается список пар строк и столбцов, минимизирующий стоимость.

---

## Теоретическая оценка сложности

1. **Временная сложность**:
   - Алгоритм имеет сложность \( O(n^3) \), где \( n \) — размер матрицы.

2. **Затраты по памяти**:
   - Используется матрица размера \( n \times n \) для хранения исходных данных, а также дополнительные массивы для покрытия строк и столбцов.

---
