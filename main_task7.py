# сложность алгоритма O (V*E)  V — количество вершин E — количество рёбер в графе

class Graph:
    def __init__(self):
        # Создаем пустой список для хранения рёбер (каждое ребро - это кортеж из начальной вершины, конечной вершины и веса)
        self.edges = []
        # Создаем множество для хранения всех уникальных вершин в графе
        self.vertices = set()
    #u - начальная вершина v - конечная вершина  weight - вес ребра 
    def add_edge(self, u, v, weight):
        # Добавляем ребро как кортеж (u, v, weight) в список рёбер
        self.edges.append((u, v, weight))
        # Добавляем вершины u и v в множество вершин
        self.vertices.update([u, v])
    #source - это ершина-источник, с которой начинаем расчет
    def bf(self, source):
        # Все расстояния изначально равны бесконечности, кроме начальной вершины (source), расстояние до которой равно 0.
        dist = {vertex: float('inf') for vertex in self.vertices}
        dist[source] = 0
        
        # вычитаем 1 так как не учитывам исходную вершину
        for i in range(len(self.vertices) - 1):
            # Флаг для отслеживания изменений на текущей итерации
            updated = False
            for u, v, weight in self.edges:  # Перебираем все рёбра в графе
                # Если путь через u короче, чем текущий известный путь к v, обновляем расстояние до v
                if dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight
                    updated = True  # Отмечаем, что на этой итерации были изменения
            # Если за итерацию не произошло ни одного обновления, завершаем алгоритм досрочно
            if not updated:
                break

        # Проверяем наличие отрицательного цикла
        for u, v, weight in self.edges:
            # Если расстояние можно улучшить, значит, существует отрицательный цикл
            if dist[u] + weight < dist[v]:
                return None  # Возвращаем None, если обнаружен отрицательный цикл

        # Возвращаем словарь с кратчайшими расстояниями до каждой вершины
        return dist

# Создаем объект графа
graph = Graph()
# Добавляем рёбра в граф: u - начальная вершина, v - конечная вершина, weight - вес ребра
graph.add_edge(0, 1, 7)
graph.add_edge(1, 2, 3)
graph.add_edge(2, 3, 4)
graph.add_edge(3, 0, 10)

# Указываем начальную вершину для поиска кратчайших путей
source = 0

# Выполняем алгоритм Беллмана-Форда и сохраняем результат
shortest_paths = graph.bf(source)
print(shortest_paths)
