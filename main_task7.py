class Graph:
    def __init__(self):
        # Создаем пустой список для хранения рёбер (каждое ребро - это кортеж из начальной вершины, конечной вершины и веса)
        self.edges = []
        # Создаем множество для хранения всех уникальных вершин в графе
        self.vertices = set()

    def add_edge(self, u, v, weight):
        """
        Добавляет направленное ребро с весом между двумя вершинами.
        u - начальная вершина (источник ребра).
        v - конечная вершина (цель ребра).
        weight - вес ребра (стоимость перехода).
        """
        # Добавляем ребро как кортеж (u, v, weight) в список рёбер
        self.edges.append((u, v, weight))
        # Добавляем вершины u и v в множество вершин
        self.vertices.update([u, v])

    def execute_bford_algorythm(self, source):
        """
        Алгоритм Беллмана-Форда для нахождения кратчайших путей от начальной вершины до всех остальных.
        
        :param source: Вершина-источник, с которой начинаем расчет.
        :return: Словарь с кратчайшими расстояниями до каждой вершины или None, если обнаружен отрицательный цикл.
        """
        # Инициализируем словарь для хранения кратчайших расстояний до каждой вершины.
        # Все расстояния изначально равны бесконечности, кроме начальной вершины (source), расстояние до которой равно 0.
        dist = {vertex: float('inf') for vertex in self.vertices}
        dist[source] = 0

        # Основной цикл: выполняем релаксацию всех рёбер |V|-1 раз, где |V| - количество вершин в графе
        for _ in range(len(self.vertices) - 1):
            # Флаг для отслеживания изменений на текущей итерации
            updated = False
            for u, v, weight in self.edges:  # Перебираем все рёбра в графе
                # Если путь через u короче, чем текущий известный путь к v, обновляем расстояние до v
                if dist[u] + weight < dist[v]:
                    dist[v] = dist[u] + weight
                    updated = True  # Отмечаем, что на этой итерации были изменения
            # Если за итерацию не произошло ни одного обновления, завершаем алгоритм досрочно
            if not updated:
                break

        # Проверяем наличие отрицательного цикла, выполняя ещё одну итерацию релаксации
        for u, v, weight in self.edges:
            # Если расстояние можно улучшить, значит, существует отрицательный цикл
            if dist[u] + weight < dist[v]:
                return None  # Возвращаем None, если обнаружен отрицательный цикл

        # Возвращаем словарь с кратчайшими расстояниями до каждой вершины
        return dist

if __name__ == '__main__':
    # Создаем объект графа
    cities_graph = Graph()
    # Добавляем рёбра в граф: u - начальная вершина, v - конечная вершина, weight - вес ребра
    cities_graph.add_edge('Москва', 'Санкт-Петербург', 7)
    cities_graph.add_edge('Санкт-Петербург', 'Выборг', 3)
    cities_graph.add_edge('Выборг', 'Рускеала', 4)
    cities_graph.add_edge('Рускеала', 'Москва', 10)

    # Указываем начальную вершину для поиска кратчайших путей
    source = 'Москва'

    # Выполняем алгоритм Беллмана-Форда и сохраняем результат
    shortest_paths = cities_graph.execute_bford_algorythm(source)

    # Выводим результат на экран
    if shortest_paths:
        # Если отрицательный цикл не обнаружен, выводим кратчайшие пути
        print(f"Кратчайшие пути от '{source}': {shortest_paths}")
    else:
        # Если обнаружен отрицательный цикл, выводим сообщение
        print("Обнаружен отрицательный цикл в графе. Кратчайшие пути не определены.")
